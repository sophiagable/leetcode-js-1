## 题目

给定一个整数数组和一个目标值，找出数组中和为目标值的两个数的索引值。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

#### 示例:

``` js
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

## 思路

``` js
a + b = target;
```

这道题还是很简单的，拿到题目直接就想到了冒泡解法，先遍历 `nums` ，`nums[i]` 就是 `a` ，再将 `nums` 中 `nums[i]` 右边的所有数字遍历一次，查找有没有那个满足条件的 `b` 。但是这样，需要遍历内嵌遍历，时间复杂度为 O(n<sup>2</sup>)，显然不是一个很好的方法。

我们可以借助 **表** 的思维，遍历 `nums` 的时候，将 `nums[i]` 存在一个对象中。每个循环中去检测对象中是否存在 `target - nums[i]` ，如果存在，那 `target - nums[i]` 和 `nums[i]` 就是我们需要寻找的值。

但是题目想要我们给出的是两个数的索引，所以 `nums[i]` 作为 `key` ，`i` 需要作为 `value` ，利用 `nums[i]` 从对象中取值(索引)即可。
